<!-- title -->
<h1 align="center">
    <img alt="docker image" src="https://cdn.icon-icons.com/icons2/2699/PNG/512/docker_official_logo_icon_169250.png" width="200px">
</h1>

## Introduction
O Docker √© uma ferramenta que usamos para tornar f√°cil a configura√ß√£o de softwares em computadores diferentes.


<br>

ü§î Imagine o seguinte cen√°rio:


Um dev desenvolveu uma API/software, utilizando SPRING 3.0 + JAVA 17.0 + POSTGRESQL, e precisa mandar uma copia do projeto para os 2 devs do seu time. Os dois devs tentaram rodar o projeto e n√£o funcionou.

Aquele ditado... 

> "U√©?? Na minha m√°quina funciona".

1. Dev1 --> O projeto n√£o rodou porque ele n√£o tinha o postgres instalado.
1. Dev2 --> O projeto n√£o rodou porque sua m√°quina n√£o tinha a versao 17 do Java e sim a versao 8.

O **docker** surgiu para resolver esse problema.

O Docker √© uma ferramenta que visa ajudar os desenvolvedores em uma equipe, garantindo que a aplica√ß√£o/software funcione de maneira consistente em diferentes computadores.


<br>

ü§î Imagine o seguinte cen√°rio:

Voc√™ est√° participando de 2 projetos:
1. Projeto1 --> Utiliza java 8
2. Projeto2 --> Utiliza java 17

Para n√£o precisar instalar 2 versoes do java no seu computador, voce simplesmente cria um container para cada aplicacao.

<hr>
<br>

##  Virtual Machine (VMs) VS Docker

1. M√°quinas Virtuais (VMs):
    - Cada VM possui um sistema operacional(OS) COMPLETO, contendo drivers, aplicativos, etc... Ou seja, consome MUITO recurso do nosso computador. 

2. Docker (Container):
    - Aqui, os containers compartilham do mesmo sistema operacional do host do computador. Ou seja, n√£o precisam instalar um sistema operacional completo. Aqui, virtualizamos apenas os softwares que desejarmos. Logo, trabalhar com containers √© muito mais leve e consome menos recursos do computador.



<hr>
<br>

## Dockerfile -> Docker Image -> Docker Container

<div align="center">
    <img src="../img/docker_flow.png" alt="docker flow image" width="650px">
</div>

<br>

1. Dockerfile

    - Arquivo de texto que cont√©m as instru√ß√µes e configura√ß√µes para construir uma docker image(executavel). √â a blue print de uma docker image.

<br>

1. docker image
    
    - √â o pacote execut√°vel. Esse eh o execut√°vel que vai criar um "computador" com apenas os softwares necessarios para nossa aplicacao funcionar.

<br>

1. docker container

    - √â uma inst√¢ncia em execu√ß√£o de uma Docker Image. √â um ambiente isolado que cont√©m tudo o que sua aplica√ß√£o precisa para rodar. Pode ser comparado a uma m√°quina virtual, mas √© mais leve e compartilha o mesmo sistema operacional do host.

<br>


<hr>
<br>

## Comandos mais usados

- image commands:

    - `docker search` --> Lista as images dispon√≠veis no [docker hub](https://hub.docker.com/).

    - `docker pull` --> Baixa uma docker image (exec√∫tavel) do [docker hub](https://hub.docker.com/).

    - `docker images` --> Lista todas as images (executaveis) baixados na nossa maquina local

    - `docker rmi` --> Remove uma image (execut√°vel) local

    - `docker build` --> Cria uma image (execut√°vel) com base em um dockerfile

<br>


- container commands:

    - `docker ps -a` --> Lista todos os containers, inclusive os que est√£o parados.
    
    - `docker create --name` --> Cria um container e altere o "name" dele. √â legal nomear esses containers porque conseguimos referenci√°-los depois (Deletar,etc..).

    - `docker start 'containerTal' -p 3322:44` --> Starta um container. Perceba que usamos 2 parametros/flags/options.
        
        - Informamos o nome do container que queremos startar.
        - Informamos a porta que vamos usar na nossa maquina local para acessar a porta do ambiente virtualizado.

    <br>

    - `docker stop` --> Desliga um container.

    - `docker rm` --> Remove um container

<hr>
<br>

## Docker flow

(**Alterar depois**)

Imagine que voc√™ criou uma API e seu time precisa testa-la. Para que eles consigam ter as mesmas configuracoes da sua m√°quina local, voc√™ precisa criar uma docker image e disponibilizar para eles.

O fluxo de trabalho de uma equipe utilizando o docker seria esse:

Disponibilizando a Aplica√ß√£o para a Equipe:

1. Eu vou criar uma API e disponibilizar para meu time.
    1. Cria√ß√£o do Dockerfile: Escreva um Dockerfile para definir como a imagem Docker ser√° constru√≠da.

    2. Constru√ß√£o da Imagem Docker: Construo a image (executavel) usando o Dockerfile.

    3. Compartilhamento da Imagem: Disponibilizo a imagem para a equipe, seja por upload para o Docker Hub ou outra forma de compartilhamento.

<br>

2. Equipe Baixando e Executando a Aplica√ß√£o:

    1. Download da Imagem Docker: Cada membro da equipe baixa a imagem usando o comando `docker pull`.

    2. Execu√ß√£o do Cont√™iner: Cada membro da equipe executa o comando `docker run` para criar e executar um cont√™iner. Assim, eles v√£o ter um "ambiente virtual/maquina virtual" identico ao que voc√™ usou para desenvolver a API.

    3. Agora sim, eles conseguem rodar a aplicacao sem problemas.


<hr>
<br>

## Expondo as portas de um container
Para ficar mais f√°cil o entendimento, vamos tratar os containers como "computadores virtuais, contendo apenas determinados softwares".

Entao, quando acessamos um container, estamos acessando um "outro computador".


ü§î Imagine o seguinte cen√°rio:

Imagine um computador que possua apenas o **Apache Tomcat** instalado (inclusive o spring utiliza esse servidor por debaixo dos panos). Por padr√£o, sempre que √© instalado o **Apache Tomcat** ou um **nginx**, √© liberado uma porta no nosso computador para acessar esse servidor:

- Apache Tomcat --> Libera o servidor na porta `8080`
- Nginx --> Libera o servidor na porta `80`

Para acessar essa porta no nosso computador local √© moleza. Basta acessarmos:

- `http://localhost:8080`
- `http://localhost:80`

<br>

Mas quando estamos trabalhando com containers, √© como se estiv√©ssemos instalando o Apache / Nginx em outros computadores.

Para acessar esses computadores e acessar a porta que foi liberada desse computador virtual(container), precisamos fazer uma conexao entre uma porta do nosso computador local e a porta exposta pelo computador virtual(container).

‚úèÔ∏è Crie 1 container (computador virtual) contendo apenas o **Apache Tomcat**. Depois, fa√ßa a conexao das portas entre o seu computador local e o computador virtual(container).

```bash
docker pull tomcat #Baixamos o docker image(execut√°vel para instalar o computador virtual), contendo apenas o apache;
docker run --name computador1 -d -p 1234:8080 69bd221063cf; #startamos o computador virtual()
```

üí°Perceba que n√≥s usamos duas flags:

- `-d` --> Rodamos o computador(container) e depois voltamos para nosso terminal padrao.
- `-p` --> fazemos a conexao de uma porta do nosso computador local com a porta exposta do container.


Perceba que a porta `1234` do seu computador local consegue acessar a porta `8080` do computador virtual(container).

<br>
<br>


‚úèÔ∏è Crie 1 container (computador virtual) contendo apenas o **Nginx**. Depois, fa√ßa a conexao das portas entre o seu computador local e o computador virtual(container).

```bash
docker pull nginx #Baixamos o docker image(execut√°vel para instalar o computador virtual), contendo apenas o Nginx;
docker run --name computador1 -d -p 1234:8080 69bd221063cf; #startamos o computador virtual()
```

üí°Perceba que n√≥s usamos duas flags:

- `-d` --> Rodamos o computador(container) e depois voltamos para nosso terminal padrao.
- `-p` --> fazemos a conexao de uma porta do nosso computador local com a porta exposta do container.


Perceba que a porta `1234` do seu computador local consegue acessar a porta `8080` do computador virtual(container).